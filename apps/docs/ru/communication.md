# Коммуникация между нативными клиентами и мини-приложениями

Достаточно тяжело представить какое-либо мини-приложение без коммуникации между нативным клиентом и встроенным мини-приложением. Под "коммуникацией", конечно, подразумевается обмен данными посредством взаимного вызова событий.

Этот документ предоставляет инструкцию и рекомендации по реализации безопасного и стабильного обмена данными между нативным клиентом и мини-приложением.

## События

Под **событиями** понимаются сообщения, создаваемые нативным клиентом и отправляемые мини-приложению. Они могут быть инициированы внешними факторами, такими как, например, смена цветовой схемы пользователем, либо же в случае вызовов [методов](#методы). В случае получения какого-либо события, у приложения есть возможность выполнить соответствующую реакцию, например - при изменении цветовой схемы нативного клиента, изменить цвет элементов в мини-приложении.

[//]: # (TODO: Add illustration?)

Каждое из событий имеет следующий набор данных:

1. **Уникальное название**. Например, `palette_changed`
2. **Опциональные дополнительные данные**. Например, `{ footer: '#aa0922' }`
3. **Опциональный идентификатор запроса**. Это поле обязательно в случае, если событие было сгенерировано в результате вызова [метода](#методы), и должно быть равно идентификатору запроса, указанного в событии метода

Таким образом, этому набору данных будет соответствовать следующий интерфейс TypeScript:

```typescript
interface EventData<Name extends string, Payload> {
  name: Name;
  payload: Payload;
  requestId?: number;
}
```

## Методы

**Методы** - это [события](#события), инициированные мини-приложением и направленные нативному клиенту. Единственная задача методов - инициировать какое-либо действие в нативном клиенте. Примером могут служить следующие действия:

- Запрос текущей цветовой палитры
- Получение данных пользователя
- Использование специфичного для нативного клиента функционала

Структурно, события методов ничем не отличаются от обычных событий за одним исключением - при создании события метода, указание `requestId` обязательно. Таким образом, конечный интерфейс события метода является следующим:

```typescript
interface MethodEventData<Name extends string, Payload> {
  name: Name;
  payload: Payload;
  requestId: number;
}
```

В результате вызова метода, нативный клиент обязан сгенерировать событие, говорящее о том, был ли вызов метода успешен.

[//]: # (FIXME: Подробнее об этой теме можно узнать вот тут &#40;и раздел&#41;)

## Канал коммуникации

Ввиду того, что мини-приложения работают только в веб-среде, при проектировании канала коммуникации важно учитывать её ограничения. Например, в случае, если в качестве нативного клиента выступает веб-клиент, и мини-приложение вставляется посредством использования HTML-тега `iframe`, то способ коммуникации с таким мини-приложением сужается до лишь одного, принятого в мире веб-разработки - при помощи использования метода [`window.postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) и события [`message`](https://developer.mozilla.org/en-US/docs/Web/API/Window/message_event).

В целях минимизации расхождений реализации такого канала коммуникации, стандарт сводит имплементацию на всех нативных клиентах к алгоритму, принятому в мире веб-разработки.

### В веб-клиентах

Для отправки события от веб-клиента мини-приложению, клиент должен использовать стандартный способ отправки сообщения iframe-у, при помощи вызова метода `iframe.contentWindow.postMessage`. Ввиду того, что некоторые старые браузеры поддерживают лишь передачу строки в метод `postMessage`, в качестве значения необходимо передать объект, описанный в секции [События](#события), и привести его к строке при помощи метода `JSON.stringify`:

```typescript
iframe.contentWindow.postMessage(
  JSON.stringify({
    name: 'palette_changed',
    payload: {
      header: '#b19821',
      footer: '#aa726d',
    },
  }),
  'https://initial-mini-app.domain',
);
```

Для получения события метода от мини-приложения, достаточно использовать слушатель события `message`:

```js
window.addEventListener('message', e => {
  // Проверяем, что событие пришло от вставленного iframe. В целях 
  // безопасности также проверяем, что его домен не изменился.
  if (
    e.source !== iframe.contentWindow
    || e.origin !== 'https://initial-mini-app.domain'
  ) {
    return;
  }
  // Обрабатываем запрос.
  // ...
});
```

### В десктопных и мобильных клиентах

Говоря же о мобильных и десктопных клиентах, канал коммуникации немного отличается от принятого в веб-клиентах. Для передачи события, нативные клиенты такого рода должны вставлять JavaScript-код, имитирующий поведение, описанное в секции "[В веб-клиентах](#в-веб-клиентах)".

Таким образом, реализация для Android WebView может выглядеть следующим образом:

```java
webView.evaluateJavascript(
  "window.postMessage(
    JSON.stringify({
      name: 'palette_changed',
      payload: { footer: '#0988a1' }
    }),
    'https://initial-mini-app.domain',
  )", 
  null
);
```

Для получения события метода от мини-приложения, достаточно инициализировать мост (bridge). С точки зрения мини-приложения, под мостом понимается некоторое поле в глобальном объекте `window`, которое предоставляет интерфейс для отправки событий.

Для минимизации расхождений между реализациями, стандарт требует следующее:

<!-- TODO: Что если вставлять мини-приложение через такой же iframe? Тогда реализация будет полностью единой,
а каждый нативный клиент сможет обрабатывать событие как захочет через тот же `window.addEventListener`. -->

1. Нативный клиент должен объявить поле `window.__miniAppsBridge__`, со следующим интерфейсом:

```typescript
window.__miniAppsBridge__ = {
  postMessage(methodData: MethodEventData) {
    // ...
  }
};
```

Определение типа `MethodEventData` можно найти в разделе [Методы](#методы).

Таким образом, мини-приложение должно иметь возможность вызвать метод при помощи следующего кода:

```typescript
window.__miniAppsBridge__.postMessage({
  name: 'request_user_data',
  payload: {
    user_id: 279058397,
  },
  request_id: 1,
});
```

2. Ввиду того, что реализация передачи данных от мини-приложения к нативному клиенту может сильно разниться в зависимости от самого нативного клиента, реализация метода `window.__miniAppsBridge__.postMessage` лежит на нативном клиенте.

### В мини-приложениях

Исходя из требований к реализации канала коммуникации, описанных в разделах "[В нативных веб-клиентах](#в-веб-клиентах)" и "[В десктопных и мобильных клиентах](#в-нативных-веб-клиентах)", имплементация канала коммуникации в мини-приложении сводится к следующему:

1. Если мини-приложение было помещено в HTML-тег `iframe`, то для вызова метода необходимо использовать следующий код:

```js
window.parent.postMessage(
  JSON.stringify({
    name: 'request_user_data',
    payload: {
      user_id: 279058397,
    },
    requestId: 1,
  }),
  'https://trusted.domain'
);
```

В противном случае, необходимо использовать мост:

```js
window.__miniAppsBridge__.postMessage({
  name: 'request_user_data',
  payload: {
    user_id: 279058397,
  },
  requestId: 1,
});
```

2. В независимости от нативного клиента, для получения события необходимо отслеживать событие `message`:

```js
window.addEventListener('message', e => {
  // Проверяем, что событие пришло от доверенного домена, либо
  // же было сгенерировано текущим мини-приложением 
  // (или нативным мобильным или десктопным клиентами).
  if (e.origin === 'https://trusted.domain' || e.source === window.self) {
    // Событию можно доверять.
    // ...
  }
});
```


[//]: # (todo: response events)
[//]: # (TODO: Возможно, в механизмах безопасности стоит генерировать ошибочные события, говорящие о том, что домен изменился)
